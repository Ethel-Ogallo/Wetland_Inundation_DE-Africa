def mask_clouds_qa_pixel(ds):
    pq = ds.pixel_quality  # QA_PIXEL band

    # Bit flags: 1 = dilated cloud, 2 = cirrus, 3 = cloud, 4 = shadow
    dilated_cloud = 1 << 1
    cirrus = 1 << 2
    cloud = 1 << 3
    shadow = 1 << 4

    # Mask where none of those bits are set
    cloud_mask = (pq & (dilated_cloud | cirrus | cloud | shadow)) == 0

    # filter out nodata and saturated values
    valid_data_mask = (ds > 1).to_array("band").all("band")

    # Apply masks
    ds = odc.algo.keep_good_only(ds, where=valid_data_mask)
    ds = odc.algo.erase_bad(ds, where=~cloud_mask)

    return ds

# Apply the function to your dataset
ds_masked = mask_clouds_qa_pixel(ds_ls)



## Define AOI mask 
# bounding box of aoi
bbox_coords = [
    (lon - buffer, lat - buffer),
    (lon + buffer, lat - buffer),
    (lon + buffer, lat + buffer),
    (lon - buffer, lat + buffer),
    (lon - buffer, lat - buffer)  
]

# Create the GeoDataFrame using GeoPandas
gdf = gpd.GeoDataFrame({"col1": ["name"]}, 
                       geometry=[Polygon(bbox_coords)], #Polygon representing the bounding box (Shapely format)
                       crs="EPSG:4326")

# Reproject to match Landsat CRS
gdf = gdf.to_crs(epsg=32636)

# Check the GeoDataFrame (gdf)
print(gdf)

# Use a single time slice for rasterization to reduce memory load
template = ds_masked.isel(time=0)

# Rasterize AOI polygon
mask = xr_rasterize(gdf, template)

# Apply mask to entire dataset
ds_ls_mask = ds_masked.where(mask)

print(ds_ls_mask)


ds_ls_nm = ds_ls_mask / 10000

# Visualize one time step of raw TCW
tcw_raw = calculate_indices(
    ds_ls_nm, index=["TCW"], normalise=False,
    satellite_mission="ls", drop=True
)

tcw_raw_res = tcw_raw.resample(time="1M").max()



tcw_raw_res.TCW.isel(time=[0,1,2,3,4,5]).plot.imshow(col='time',col_wrap=4,cmap='Blues',size=6)


from skimage.filters import threshold_otsu

flat = tcw_raw.TCW.values.flatten()
flat = flat[~np.isnan(flat)]
otsu_thresh = threshold_otsu(flat)
print("Otsu threshold:", otsu_thresh)


#Calculate the TCW index
verbose = True
TCW_threshold = otsu_thresh #The tasseled cap wetness threshold, beyond which a pixel will be considered 'wet'. Defaults to -0.035
ds_ls_nm = ds_ls_mask / 10000 # Normalize the data by dividing the data by 10,000.


if verbose:
    print("calculating tasseled cap wetness index ")

with HiddenPrints():  # suppres the prints from this function
    tcw_result = calculate_indices(
        ds_ls_nm, 
        index=["TCW"], 
        normalise=False, 
        satellite_mission="ls", 
        drop=True
    )

#resample monthly
if verbose:
    print("Resampling TCW to 1M" )
tcw_res = tcw_result.resample(time="1M").max()


tcw = tcw_res.TCW >= TCW_threshold
tcw = tcw.where(mask, 0)
tcw = tcw.persist()

print(tcw)


## VIZUALIZATION TCW (for paper and presentation)
import os
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches

# Output directories
os.makedirs('output/maps/tcw', exist_ok=True)

# Dates to plot
plot_dates = ['2021-12-31', '2021-11-30', '2021-10-31', '2021-09-30']

# Loop over selected dates
for date in plot_dates:
    data = tcw.sel(time=date)
    
    fig, ax = plt.subplots(figsize=(8, 6))
    im = data.plot.imshow(ax=ax, cmap='Blues', add_colorbar=False)
    
    ax.set_title(f'TCW Mask - {date}', fontsize=14)
    # Set axis with lat/lon labels
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.tick_params(labelsize=8)
    
    # Get the colormap and map the actual data values to the color
    cmap = plt.get_cmap('Blues')
    wet_color = cmap(1.0)  # for value 1
    dry_color = cmap(0.0)  # for value 0
    
    # Create matching legend patches
    wet_patch = mpatches.Patch(color=wet_color, label='1 = Wet')
    dry_patch = mpatches.Patch(color=dry_color, label='0 = Not wet')
    ax.legend(handles=[dry_patch, wet_patch], loc='upper left')

    fig.tight_layout()
    fig.savefig(f'output/maps/tcw/tcw_{date}.png')
    plt.close()


# VISUALIZATION WOfS (for paper and presenattion)
# Output directories
os.makedirs('output/maps/wofs', exist_ok=True)

# Dates to plot
plot_dates = ['2021-12-31', '2021-11-30', '2021-10-31', '2021-09-30']

# Loop over selected dates
for date in plot_dates:
    data = wofs_wet.sel(time=date)
    
    fig, ax = plt.subplots(figsize=(8, 6))
    im = data.plot.imshow(ax=ax, cmap='Blues', add_colorbar=False)
    
    ax.set_title(f'WOfS Mask - {date}', fontsize=14)
    # Set axis with lat/lon labels
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.tick_params(labelsize=8)
    
    # Use actual colors from the reversed 'Blues_r' colormap
    cmap = plt.get_cmap('Blues')
    wet_color = cmap(1.0)  # value 1 = darkest blue in reversed cmap
    dry_color = cmap(0.0)  # value 0 = lightest blue (almost white)

    wet_patch = mpatches.Patch(color=wet_color, label='1 = Water')
    dry_patch = mpatches.Patch(color=dry_color, label='0 = No water')
    ax.legend(handles=[dry_patch, wet_patch], loc='upper left')

    fig.tight_layout()
    fig.savefig(f'output/maps/wofs/wofs_{date}.png')
    plt.close()


# VIZUALIZATION FC
os.makedirs('output/maps/fc', exist_ok=True)

for date in plot_dates:
    fc_sel = fc_masked.sel(time=date)

    # Compute RGB channels
    r = fc_sel['bs'].values / 100  # Bare Soil → Red
    g = fc_sel['pv'].values / 100  # Photosynthetic Veg → Green
    b = fc_sel['npv'].values / 100  # Non-Photosynthetic Veg → Blue

    rgb = np.stack([r, g, b], axis=-1)
    rgb = np.clip(rgb, 0, 1)

    # Get coordinate extents (x = longitude, y = latitude)
    x_coords = fc_sel['x'].values
    y_coords = fc_sel['y'].values
    extent = [x_coords.min(), x_coords.max(), y_coords.min(), y_coords.max()]  # [xmin, xmax, ymin, ymax]

    # Plot
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.imshow(rgb, extent=extent, origin='upper')  # Match orientation to geodata

    # Legend
    legend_patches = [
        mpatches.Patch(color='red', label='Bare Soil (R)'),
        mpatches.Patch(color='green', label='Green Veg (G)'),
        mpatches.Patch(color='blue', label='Dry Veg (B)')
    ]
    ax.legend(handles=legend_patches, loc='lower right')

    # Set axis with lat/lon labels
    ax.set_xlabel('Longitude')
    ax.set_ylabel('Latitude')
    ax.set_title(f'Fractional Cover - {date}')
    ax.tick_params(labelsize=8)

    plt.tight_layout()
    plt.savefig(f'output/maps/fc/fc_rgb_{date}.png', dpi=150)
    plt.close()

# visualize clear and dry
clear_and_dry.isel(time=[0,1,2,3,4,5]).plot.imshow(col='time',col_wrap=4, size = 6);

# mask with TC wetness
fc_ds_noTCW = fc_masked.where(tcw == False)  # noqa E712

if verbose:
        print("Generating classification")

# Cast the dataset to a DataArray
fc_ds_noTCW = fc_ds_noTCW.to_array(dim="variable", name="fc_ds_noTCW")

# turn FC array into integer only as nanargmax doesn't seem to handle floats the way we want it to
fc_int = fc_ds_noTCW.astype("int8")

# use nanargmax to get the index of the maximum value
BSPVNPV = fc_int.argmax(dim="variable")

# int dytype remocves NaNs so we need to create mask again
FC_mask = np.isfinite(fc_ds_noTCW).all(dim="variable")
BSPVNPV = BSPVNPV.where(FC_mask)

# Restack the Fractional cover dataset all together
    # CAUTION:ARGMAX DEPENDS ON ORDER OF VARIABALES IN
    # DATASET. NEED TO ADJUST BELOW DEPENDING ON ORDER OF FC VARIABLES

FC_dominant = xr.Dataset(
    {
        "bs": (BSPVNPV == 2).where(FC_mask),
        "pv": (BSPVNPV == 0).where(FC_mask),
        "npv": (BSPVNPV == 1).where(FC_mask),
    }
)

# pixel counts
pixels = mask.sum(dim=["x", "y"])

verbose_progress=True
if verbose_progress:
    print("Computing wetness")
tcw_pixel_count = tcw.sum(dim=["x", "y"]).compute()

if verbose_progress:
    print("Computing green veg, dry veg, and bare soil")
FC_count = FC_dominant.sum(dim=["x", "y"]).compute()

if verbose_progress:
    print("Computing open water")
wofs_pixels = wofs_wet.sum(dim=["x", "y"]).compute()

# count percentages
wofs_area_percent = (wofs_pixels / pixels) * 100
tcw_area_percent = (tcw_pixel_count / pixels) * 100
tcw_less_wofs = tcw_area_percent - wofs_area_percent  # wet not wofs


export_csv = 'test_output_data.csv'
verbose = True  

# Fractional cover pixel count method
# Get number of FC pixels, divide by total number of pixels per polygon
BS_percent = (FC_count.bs / pixels) * 100
PV_percent = (FC_count.pv / pixels) * 100
NPV_percent = (FC_count.npv / pixels) * 100
NoData_count = (
    (100 - wofs_area_percent - tcw_less_wofs - PV_percent - NPV_percent - BS_percent) / 100
) * pixels

# Ensure we don't divide by zero or negative values
valid_pixels = (pixels - NoData_count).where((pixels - NoData_count) > 0)

# Recalculate percentages using valid_pixels
BS_percent = (FC_count.bs / valid_pixels) * 100
PV_percent = (FC_count.pv / valid_pixels) * 100
NPV_percent = (FC_count.npv / valid_pixels) * 100
wofs_area_percent = (wofs_pixels / valid_pixels) * 100
tcw_area_percent = (tcw_pixel_count / valid_pixels) * 100
tcw_less_wofs = tcw_area_percent - wofs_area_percent

# Handle negative wetness
tcw_less_wofs = tcw_less_wofs.where(tcw_less_wofs >= 0, 0)

# Setup of dataframe to hold the data
df = pd.DataFrame(
    data=wofs_area_percent.data,
    index=wofs_area_percent.time.values,
    columns=["wofs_area_percent"],
)

# Add more data to the dataframe
df["wet_percent"] = tcw_less_wofs.data
df["green_veg_percent"] = PV_percent.data
df["dry_veg_percent"] = NPV_percent.data
df["bare_soil_percent"] = BS_percent.data

# Round values to 2 decimal places
df = df.round(2)

# Export the dataframe to CSV 
if export_csv:
    if verbose:
        print("Exporting CSV: " + export_csv)
    df.to_csv(export_csv, index_label="Datetime")

# Display the DataFrame 
df


#save gif
ani.save("output/wetland_dnamics_monthly.gif", writer='pillow', fps=2)
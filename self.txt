def mask_clouds_qa_pixel(ds):
    pq = ds.pixel_quality  # QA_PIXEL band

    # Bit flags: 1 = dilated cloud, 2 = cirrus, 3 = cloud, 4 = shadow
    dilated_cloud = 1 << 1
    cirrus = 1 << 2
    cloud = 1 << 3
    shadow = 1 << 4

    # Mask where none of those bits are set
    cloud_mask = (pq & (dilated_cloud | cirrus | cloud | shadow)) == 0

    # filter out nodata and saturated values
    valid_data_mask = (ds > 1).to_array("band").all("band")

    # Apply masks
    ds = odc.algo.keep_good_only(ds, where=valid_data_mask)
    ds = odc.algo.erase_bad(ds, where=~cloud_mask)

    return ds

# Apply the function to your dataset
ds_masked = mask_clouds_qa_pixel(ds_ls)



## Define AOI mask 
# bounding box of aoi
bbox_coords = [
    (lon - buffer, lat - buffer),
    (lon + buffer, lat - buffer),
    (lon + buffer, lat + buffer),
    (lon - buffer, lat + buffer),
    (lon - buffer, lat - buffer)  
]

# Create the GeoDataFrame using GeoPandas
gdf = gpd.GeoDataFrame({"col1": ["name"]}, 
                       geometry=[Polygon(bbox_coords)], #Polygon representing the bounding box (Shapely format)
                       crs="EPSG:4326")

# Reproject to match Landsat CRS
gdf = gdf.to_crs(epsg=32636)

# Check the GeoDataFrame (gdf)
print(gdf)

# Use a single time slice for rasterization to reduce memory load
template = ds_masked.isel(time=0)

# Rasterize AOI polygon
mask = xr_rasterize(gdf, template)

# Apply mask to entire dataset
ds_ls_mask = ds_masked.where(mask)

print(ds_ls_mask)


ds_ls_nm = ds_ls_mask / 10000

# Visualize one time step of raw TCW
tcw_raw = calculate_indices(
    ds_ls_nm, index=["TCW"], normalise=False,
    satellite_mission="ls", drop=True
)

tcw_raw_res = tcw_raw.resample(time="1M").max()



tcw_raw_res.TCW.isel(time=[0,1,2,3,4,5]).plot.imshow(col='time',col_wrap=4,cmap='Blues',size=6)


from skimage.filters import threshold_otsu

flat = tcw_raw.TCW.values.flatten()
flat = flat[~np.isnan(flat)]
otsu_thresh = threshold_otsu(flat)
print("Otsu threshold:", otsu_thresh)


#Calculate the TCW index
verbose = True
TCW_threshold = otsu_thresh #The tasseled cap wetness threshold, beyond which a pixel will be considered 'wet'. Defaults to -0.035
ds_ls_nm = ds_ls_mask / 10000 # Normalize the data by dividing the data by 10,000.


if verbose:
    print("calculating tasseled cap wetness index ")

with HiddenPrints():  # suppres the prints from this function
    tcw_result = calculate_indices(
        ds_ls_nm, 
        index=["TCW"], 
        normalise=False, 
        satellite_mission="ls", 
        drop=True
    )

#resample monthly
if verbose:
    print("Resampling TCW to 1M" )
tcw_res = tcw_result.resample(time="1M").max()


tcw = tcw_res.TCW >= TCW_threshold
tcw = tcw.where(mask, 0)
tcw = tcw.persist()

print(tcw)



